# -*- coding: utf-8 -*-
"""HPC-3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hWbNKrYLpkr_tmb_g3U0vEuqax1ANaZt

# HPC assignment 3
"""

from functools import wraps

def timefn(fn):
    from timeit import default_timer as timer

    @wraps(fn)
    def measure_time(*args, **kwargs):
        t1 = timer()
        result = fn(*args, **kwargs)
        t2 = timer()
        time_delta = t2 - t1
        return result, time_delta  # return result and time delta

    return measure_time

"""## Task 2.5
Use PyTorch to port your code to Nvidia GPUs. For this, you must express the two nested loop operations as NumPy roll operations in 2D as we did for the diffusion code. If you don't have an Nvidia GPU, you can use the Google Colab, as in [3.9.1 Tutorial: Use Google Colab GPUs for PyTorch+GPU](https://canvas.kth.se/courses/44840/pages/3-dot-9-1-tutorial-use-google-colab-gpus-for-pytorch+gpu?wrap=1 "3.9.1 Tutorial: Use Google Colab GPUs for PyTorch+GPU")[3.9.1 Tutorial: Use Google Colab GPUs for PyTorch+GPU](https://canvas.kth.se/courses/44840/pages/3-dot-9-1-tutorial-use-google-colab-gpus-for-pytorch+gpu?wrap=1 "3.9.1 Tutorial: Use Google Colab GPUs for PyTorch+GPU"))

**For this task, we use a different and simpler scheme called Jacobi, where  `f[i-1,j]` and `f[i,j-1]` are calculated at time n instead on n+1.** In this way, we remove the calculation dependencies on the new time step, and it can be easily vectorized.

"""

import torch

@timefn
def gauss_seidel_torch(f: torch.Tensor):
    """
    Applies the Gauss-Seidel method to solve a system of linear equations represented by the input tensor.

    Parameters:
    f (torch.Tensor): The input tensor representing the system of linear equations.

    Returns:
    torch.Tensor: The updated tensor after applying the Gauss-Seidel method.
    """
    newf = f.clone()

    for _ in range(1, newf.shape[0] - 1):
        newf[1:-1, 1:-1] = 0.25 * (
            torch.roll(newf, 1, dims=0)[1:-1, 1:-1]
            + torch.roll(newf, -1, dims=0)[1:-1, 1:-1]
            + torch.roll(newf, 1, dims=1)[1:-1, 1:-1]
            + torch.roll(newf, -1, dims=1)[1:-1, 1:-1]
        )

    return newf

"""## Task 2.6
Use CuPy to port your code to Nvidia GPUs. See [C.3 Tutorial - Introduction to CuPy](https://canvas.kth.se/courses/44840/pages/c-dot-3-tutorial-introduction-to-cupy?wrap=1 "C.3 Tutorial - Introduction to CuPy")[C.3 Tutorial - Introduction to CuPy](https://canvas.kth.se/courses/44840/pages/c-dot-3-tutorial-introduction-to-cupy?wrap=1 "C.3 Tutorial - Introduction to CuPy")
"""

import cupy as cp

@timefn
def gauss_seidel_cupy(f: cp.ndarray):
    """
    Applies the Gauss-Seidel method to solve a 2D array using the Cupy library.

    Args:
        f (cp.ndarray): The input 2D array.

    Returns:
        cp.ndarray: The updated 2D array after applying the Gauss-Seidel method.
    """
    newf = f.copy()

    for i in range(1, newf.shape[0] - 1):
        for j in range(1, newf.shape[1] - 1):
            newf[i, j] = 0.25 * (
                newf[i, j + 1] + newf[i, j - 1] + newf[i + 1, j] + newf[i - 1, j]
            )

    return newf

"""## Task 2.7
Measure the performance (execution time) with GPU (PyTorch and CuPy) and make a plot of the execution time varying the size of the grid. Compare and comment on the performance difference with and without GPU.
"""

import matplotlib.pyplot as plt

grid_sizes = [10, 50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]
torch_times = []
cupy_times = []

for size in grid_sizes:
    f1 = torch.rand(size, size)
    f2 = cp.random.rand(size, size)

    _, torch_time = gauss_seidel_torch(f1)
    _, cupy_time = gauss_seidel_cupy(f2)

    torch_times.append(torch_time)
    cupy_times.append(cupy_time)
    with open("torch.dat", "w") as file:
        file.write(f"{size}, {torch_time}\n")
    with open("cupy.dat", "w") as file:
        file.write(f"{size}, {cupy_time}\n")

plt.plot(grid_sizes, torch_times, label="PyTorch")
plt.plot(grid_sizes, cupy_times, label="CuPy")
plt.xlabel("Grid Size")
plt.ylabel("Execution Time (s)")
plt.title("Execution Time of Gauss-Seidel Method")
plt.legend()
plt.show()

"""## Task 2.8
Save the newgrid matrix as an hdf5 file using h5py  (see the tutorial [C.4 Tutorial - The HDF5 Library/Module](https://canvas.kth.se/courses/44840/pages/c-dot-4-tutorial-the-hdf5-library-slash-module?wrap=1 "C.4 Tutorial - The HDF5 Library/Module")[C.4 Tutorial - The HDF5 Library/Module](https://canvas.kth.se/courses/44840/pages/c-dot-4-tutorial-the-hdf5-library-slash-module?wrap=1 "C.4 Tutorial - The HDF5 Library/Module")).
"""

